/*
Прототипы
В JavaScript, объекты могут иметь другие объекты в качестве своих "прототипов". Если вы попытаетесь получить доступ
к свойству, которого нет в объекте, JavaScript будет искать его в прототипе этого объекта

Представьте, что у вас есть объект "собака", который имеет свойства "имя" и "порода".
Также у вас есть объект "животное", который является прототипом для "собаки" и имеет свойство "живое".
Даже если вы проверите свойство "живое" у "собаки", JavaScript найдет его в "животном", потому что "животное"
является прототипом "собаки".
*/

let animal = {
    eats: true
};

let dog = {
    barks: true,
    __proto__: animal
};

console.log(dog.eats); // true
console.log(dog.barks); // true

/*
В этом примере, у нас есть объект animal со свойством eats. Затем мы создаем объект dog со свойством barks и
делаем animal прототипом dog. Теперь dog может использовать свойства animal, как если бы они были его собственными.
*/



// ===================================================================//



/*
Наследование в JavaScript - это способ создания объектов, которые "наследуют" свойства и методы от других объектов.
Это как если бы у вас был общий план (или "класс") для создания объектов.
Например, у вас может быть класс "Автомобиль", который имеет свойства "марка" и "модель" и метод "ехать".
Затем вы можете создать класс "Такси", который наследует от "Автомобиля" и добавляет свое собственное свойство
"номер лицензии". Теперь каждый объект "Такси", который вы создаете, будет иметь свойства "марка", "модель"
и "номер лицензии", а также метод "ехать".
Это основы прототипов и наследования в JavaScript. Они помогают нам создавать объекты,
которые разделяют общие свойства и методы, что делает наш код более организованным и управляемым.
*/


// Родительский объект
const Animal = {
    name: '',
    say() {
        console.log(`Привет, меня зовут ${this.name}`);
    }
};

// Дочерний объект, наследующий от animal
const cat = Object.create(Animal);
cat.meow = function() {
    console.log('Мяу!');
};

// Создаем экземпляр объекта cat
const myCat = Object.create(cat);
myCat.name = 'Барсик';

myCat.say(); // Привет, меня зовут Барсик
myCat.meow(); // Мяу!





// ===================================================================//
//            Задачи
// ===================================================================//


/*
1. Создайте прототип объекта "Person" с методом "Hello", который выводит приветствие в консоль.
Создайте объект "john" на основе этого прототипа и вызовите метод "sayHello", который обращается к Hello из Person.

2. Создайте родительский объект Person с методом greet, который выводит приветствие с именем.
Создайте дочерний объект Student, который наследуется от Person и добавляет свойство university.
Создайте экземпляр Student и вызовите метод greet.

3. В приведённом ниже коде создаются и изменяются два объекта.
Какие значения показываются в процессе выполнения кода?

let animal = {
  jumps: null
};
let rabbit = {
  __proto__: animal,
  jumps: true
};

alert( rabbit.jumps ); // ? (1)

delete rabbit.jumps;

alert( rabbit.jumps ); // ? (2)

delete animal.jumps;

alert( rabbit.jumps ); // ? (3)


4. У нас есть объекты:

let head = {
  glasses: 1
};

let table = {
  pen: 3
};

let bed = {
  sheet: 1,
  pillow: 2
};

let pockets = {
  money: 2000
};

С помощью свойства __proto__ задайте прототипы так, чтобы поиск любого свойства выполнялся по следующему пути:
pockets → bed → table → head. Например, pockets.pen должно возвращать значение 3 (найденное в table), а
bed.glasses – значение 1 (найденное в head).


5. Объект rabbit наследует от объекта animal.
Какой объект получит свойство full при вызове rabbit.eat(): animal или rabbit?
let animal = {
  eat() {
    this.full = true;
  }
};

let rabbit = {
  __proto__: animal
};

rabbit.eat();


6. У нас есть два хомяка: шустрый (speedy) и ленивый (lazy); оба наследуют от общего объекта hamster.
Когда мы кормим одного хомяка, второй тоже наедается. Почему? Как это исправить?

let hamster = {
  stomach: [],

  eat(food) {
    this.stomach.push(food);
  }
};

let speedy = {
  __proto__: hamster
};

let lazy = {
  __proto__: hamster
};

// Этот хомяк нашёл еду
speedy.eat("apple");
alert( speedy.stomach ); // apple

// У этого хомяка тоже есть еда. Почему? Исправьте
alert( lazy.stomach ); // apple

*/

















