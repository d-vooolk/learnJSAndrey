/*
Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена.
Другими словами, замыкание даёт вам доступ к Scope внешней функции из внутренней функции.
В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.
*/

function makeFunc() {
    let name = "Mozilla";

    function displayName() {
        alert(name);
    }

    return displayName;
}

let myFunc = makeFunc();
myFunc();


/*
Если выполнить этот код, то строка "Mozilla" будет показана в JavaScript alert диалоге. Внутренняя функция displayName() была возвращена из внешней до того, как была выполнена.
На первый взгляд, кажется неочевидным, что этот код правильный, но он работает.
В некоторых языках программирования локальные переменные-функции существуют только во время выполнения этой функции.
После завершения выполнения makeFunc() можно ожидать, что переменная name больше не будет доступна.
Однако, поскольку код продолжает нормально работать, очевидно, что это не так в случае JavaScript.

Причина в том, что функции в JavaScript формируют так называемые замыкания.
Замыкание — это комбинация функции и лексического окружения, в котором эта функция была объявлена.
Это окружение состоит из произвольного количества локальных переменных, которые были в области действия функции во
время создания замыкания.
*/

function makeAdder(x) {
    return function(y) {
        return x + y;
    };
}

let add5 = makeAdder(5);
let add10 = makeAdder(10);

console.log(add5(2));  // 7
console.log(add10(2)); // 12

/*
Здесь мы определили функцию makeAdder(x), которая получает единственный аргумент x и возвращает новую функцию.
Эта функция получает единственный аргумент y и возвращает сумму x и y.

По существу makeAdder — это фабрика функций: она создаёт функции, которые могут прибавлять определённое
значение к своему аргументу. В примере выше мы используем нашу фабричную функцию для создания двух новых функций —
одна прибавляет 5 к своему аргументу, вторая прибавляет 10.

add5 и add10 — это примеры замыканий. Эти функции делят одно определение тела функции,
но при этом они сохраняют различные окружения. В окружении функции add5 x — это 5, в то время как в
окружении add10 x — это 10.
*/





// ================================================================================== //
//                   Задачи
// ================================================================================== //

/*
1. Здесь мы делаем два счётчика: counter и counter2, используя одну и ту же функцию makeCounter.
   Они независимы? Что покажет второй счётчик?

function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();
let counter2 = makeCounter();

alert( counter() ); // 0
alert( counter() ); // 1

alert( counter2() ); // ?
alert( counter2() ); // ?


2. Здесь объект счётчика создан с помощью функции-конструктора.
Будет ли он работать? Что покажет?

function Counter() {
  let count = 0;

  this.up = function() {
    return ++count;
  };
  this.down = function() {
    return --count;
  };
}

let counter = new Counter();

alert( counter.up() ); // ?
alert( counter.up() ); // ?
alert( counter.down() ); // ?


3. Посмотрите на код. Какой будет результат у вызова на последней строке?

let phrase = "Hello";

if (true) {
  let user = "John";

  function sayHi() {
    alert(`${phrase}, ${user}`);
  }
}

sayHi();


4. Напишите функцию sum, которая работает таким образом: sum(a)(b) = a+b.
Да, именно таким образом, используя двойные круглые скобки (не опечатка).
sum(1)(2) = 3
sum(5)(-1) = 4


5. У нас есть массив объектов, который нужно отсортировать:
let users = [
  { name: "John", age: 20, surname: "Johnson" },
  { name: "Pete", age: 18, surname: "Peterson" },
  { name: "Ann", age: 19, surname: "Hathaway" }
];

Обычный способ был бы таким:
// по имени (Ann, John, Pete)
users.sort((a, b) => a.name > b.name ? 1 : -1);

// по возрасту (Pete, Ann, John)
users.sort((a, b) => a.age > b.age ? 1 : -1);

Можем ли мы сделать его короче, например вот таким?

users.sort(byField('name'));
users.sort(byField('age'));

То есть чтобы вместо функции мы просто писали byField(fieldName).

Напишите функцию byField, которая может быть использована для этого.
*/























