/*
// ================================================================================= //
                     Асинхронные операции и промисы в JavaScript
// ================================================================================= //

JavaScript, как однопоточный язык, имеет тенденцию блокировать выполнение кода
при выполнении долгих операций, таких как сетевые запросы или чтение файлов.
Асинхронность позволяет выполнять такие операции параллельно без блокировки основного
потока выполнения.



// ================================================================================= //
                                    Промисы
// ================================================================================= //

Промисы представляют собой обертку вокруг асинхронной операции,
которая может завершиться успешно (resolved) или с ошибкой (rejected).
Они позволяют структурировать и управлять асинхронным кодом более легко и читаемо.

Пример: Создание и использование промиса

*/
// Создание промиса
const myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    const randomNumber = Math.random();
    if (randomNumber > 0.5) {
      resolve(randomNumber); // Промис выполнен успешно
    } else {
      reject(new Error('Случайное число слишком мало')); // Промис завершен с ошибкой
    }
  }, 1000);
});

// Использование промиса
myPromise
  .then(result => {
    console.log('Промис выполнен успешно. Результат:', result);
  })
  .catch(error => {
    console.error('Промис завершен с ошибкой:', error);
  });

/*



// ================================================================================= //
                        Практическое применение промисов
// ================================================================================= //

Промисы наиболее полезны при работе с асинхронными операциями, такими как запросы к
серверу или чтение файлов.

Пример: Запрос к API с использованием промисов

*/
// Промис для выполнения запроса
function fetchUserData(userId) {
  return new Promise((resolve, reject) => {
    fetch(`https://api.example.com/users/${userId}`)
    .then(response => {
    if (!response.ok) {
        throw new Error('Ошибка при выполнении запроса');
    }
    return response.json();
})
    .then(data => {
        resolve(data); // Возвращаем полученные данные
    })
    .catch(error => {
        reject(error); // Возвращаем ошибку
    });
});
}

// Использование промиса
fetchUserData(1)
    .then(userData => {
        console.log('Данные пользователя:', userData);
    })
    .catch(error => {
        console.error('Ошибка при получении данных пользователя:', error);
    });



/*
// ================================================================================= //
                        Продвинутые возможности промисов
// ================================================================================= //

Промисы также обладают дополнительными функциями, позволяющими управлять группой асинхронных задач.

Пример: `Promise.all` для обработки нескольких промисов
*/
const promise1 = fetchUserData(1);
const promise2 = fetchUserData(2);
const promise3 = fetchUserData(3);

Promise.all([promise1, promise2, promise3])
    .then(results => {
        console.log('Результаты всех промисов:', results);
    })
    .catch(error => {
        console.error('Ошибка при выполнении промисов:', error);
    });


/*
// ================================================================================= //
                        Асинхронные функции (async/await)
// ================================================================================= //

Асинхронные функции представляют собой синтаксический сахар над промисами,
что делает асинхронный код более читаемым.

Использование `async/await`

*/

// Объявление асинхронной функции fetchData
async function fetchData() {
    try {
        // Ждем, пока выполнится асинхронная операция fetchUserData(1)
        const userData = await fetchUserData(1);
        console.log('Данные пользователя:', userData);
    } catch (error) {
        console.error('Ошибка при получении данных пользователя:', error);
    }
}

// Вызов асинхронной функции fetchData
fetchData();


/*
Объяснение:

async function fetchData(): Мы объявляем асинхронную функцию с именем fetchData.
Ключевое слово async перед function указывает, что эта функция будет содержать асинхронный код.

await fetchUserData(1): Ключевое слово await используется внутри асинхронной функции для приостановки
выполнения функции до тех пор, пока промис, возвращаемый функцией fetchUserData(1), не завершится
(будет выполнен или отклонен). Здесь мы ожидаем результат выполнения функции fetchUserData(1).

const userData = await fetchUserData(1): После завершения промиса, возвращенного fetchUserData(1),
его результат (или ошибка) будет сохранен в переменной userData. Продолжение выполнения кода будет
зависеть от того, завершился промис успешно или с ошибкой.

console.log('Данные пользователя:', userData): Если промис fetchUserData(1) успешно завершится,
то данные пользователя будут выведены в консоль.

catch (error): Блок catch будет выполнен, если промис fetchUserData(1) завершится с ошибкой.
В этом случае сообщение об ошибке будет выведено в консоль.

fetchData(): Мы вызываем асинхронную функцию fetchData(), чтобы начать выполнение асинхронного кода
внутри неё.
*/
